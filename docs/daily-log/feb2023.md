<script setup>
import FoldCode from '../.vitepress/components/FoldCode.vue'

</script>

# Feb. 2023

## 1 st
### [Vitepress](https://vitepress.vuejs.org/guide/theme-search#search) [docsearch](https://docsearch.algolia.com/)
* 使用 algolia 新增搜尋功能
  > 1. 註冊 [algolia](https://www.algolia.com/)
  > 2. 在 algolia 創建 index 並獲取<br>`Application ID`、`Search-Only API Key`、`Admin API Key`
  > 3. 修改 `docs/.vitepress/config.ts`
  > ```ts
  > defineConfig({
  >   themeConfig: {
  >     ...
  >   },
  >   algolia: {
  >     appId: '', // 填入 Application ID
  >     apiKey: '', // 填入 Search-Only API Key
  >     indexName: '' // 填入剛剛創建的 index 名稱
  >   },
  > })
  > ```
  > 4. 修改 Github Secrets<br>
  > `Your Repo -> Settings -> Security / Secrets and variables / Actions`<br>
  > 新增兩個 repository secret
  > * `API_KEY`：填入 `Admin API Key`
  > * `APPLICATION_ID`：填入 `Application ID`
  > 5. 在專案的根目錄下創建 `crawlerConfig.json`<br>
  > 這是告訴 algolia 需要爬取的配置
  > ```json
  > {
  >   "index_name": "...", // 填入 index 名稱
  >   "start_urls": ["..."], // 填入專案網址
  >   "rateLimit": 8,
  >   "maxDepth": 10,
  >   "selectors": {
  >     "lvl0": {
  >       "selector": "",
  >       "defaultValue": "Documentation"
  >     },
  >     "lvl1": ".content h1",
  >     "lvl2": ".content h2",
  >     "lvl3": ".content h3",
  >     "lvl4": ".content h4",
  >     "lvl5": ".content h5",
  >     "content": ".content p, .content li"
  >   },
  >   "selectors_exclude": [
  >     "aside",
  >     ".page-footer",
  >     ".next-and-prev-link",
  >     ".table-of-contents"
  >   ],
  >   "js_render": true
  > }
  > ```
  > 6. 在 `.github/workflows` 目錄下，建立 `algolia.yml` 檔案（名稱可自行更改）
  > ```yaml
  > name: algolia
  > on:
  >   push:
  >     branches:
  >       - main # 若主分支為 master 記得更改
  > jobs:
  >   algolia:
  >     runs-on: ubuntu-latest
  >     steps:
  >       - uses: actions/checkout@v2
  >       - name: Get the content of algolia.json as config
  >         id: algolia_config
  >         run: echo "config=$(cat crawlerConfig.json | jq -r tostring)" >> $GITHUB_OUTPUT
  >       - name: Push indices to Algolia
  >         uses: signcl/docsearch-scraper-action@master
  >         env:
  >           APPLICATION_ID: ${{ secrets.APPLICATION_ID }}
  >           API_KEY: ${{ secrets.API_KEY }}
  >           CONFIG: ${{ steps.algolia_config.outputs.config }}
  > ```
  > :::info
  > 這裡是使用 Github Actions 在 Docker 中執行的 AlgoliaDocSearch scraper action，當我們推送到 `main` 分支時就會立即執行這個任務。
  > ::: 
  >
  > [⋯ Reference](https://blog.csdn.net/weixin_42429718/article/details/128361258)

## 2 nd
### VueUse
* [useWindowScroll](https://vueuse.org/core/usewindowscroll/)
  > 響應式的 window scroll。
  > ```ts
  > const { x, y } = useWindowScroll()
  > ```

### 問題
* `ref`、`computed`、`watch` 只能在 setup 使用
* `computed` 裡面不能有副作用
* `watch` 的對象只能是 `ref` 或 `function`（內部要取用到響應式資料）

### 學習資源
* [前端森林](https://fesites.netlify.app/)
  > 整理了前端知識網頁、期刊、工具等網站。
* [Learn Git Branching](https://learngitbranching.js.org/?locale=zh_TW)
  > 互動式的 git 視覺化和教學，可利用此應用程式來學習和挑戰掌握 git。

## 4 th
### 工具
* [Component Party](https://component-party.dev/)
  > 關於 Web 組件 JS 框架的語法和特性概述。

### 後端框架
* [Koa.js](https://koajs.com/)
  > 基本設置
  > 1. 安裝 Koa.js
  > ```
  > pnpm install koa -D
  > ```
  > :::tip -D
  > 將下載的套件歸類在 `package.json` 的 `devDependencies`。
  > :::
  > 2. 加入路由設定
  > ```
  > pnpm install koa-router -D
  > ```
  > 3. 加入 koa-body
  > ```
  > pnpm install koa-body -D
  > ```
  > 4. 新增 CORS
  > ```
  > pnpm install @koa/cors -D
  > ```

* 新增並設置 `server.js` 檔案

<FoldCode>

```javascript
const Koa = require('koa')
const Router = require('koa-router')
const { koaBody } = require('koa-body')
const cors = require('@koa/cors')

const app = new Koa() // 建立一個新的 Koa 實體 app
const router = new Router()

app.use(cors())
app.use(koaBody())

// Web 請求會經過這個 function
router
    .get('/url/:id', ctx => { ... })
    .delete('/url/:id', ctx => {
      ctx.params.id // 取得網址參數的 id
      ctx.request.body // 表單送過來的資料
        
      ctx.request.query // 查詢字串
      ctx.query // 查詢字串
        
      ctx.status = 200 // 回傳狀態
})

app.use(router.routes())
app.listen(3000) // 伺服器設在 3000 這個 port
```

</FoldCode>

### HTTP
* [Status Code 狀態碼](https://www.restapitutorial.com/httpstatuscodes.htmls)

| Code | Content | 意義 |
| -- | -- | -- |
| `200` | OK | 請求成功 |
| `201` | Created | 請求成功且有一個新的資源已經依據需要而被建立 |
| `204` | No Content | 請求成功，但客戶端不需要更新目前的頁面 |
| `400` | Bad Request | 被認為是客戶端錯誤，服務器不能或不會處理請求 |
| `401` | Unauthorized | 客戶端請求尚未完成，因為缺少所請求資源的有效身份驗證憑據 |
| `404` | Not Found | 服務器找不到請求的資源 |


<style>

  .vp-doc th {
    min-width: 4.7rem;
  }
</style>

## 6 th
### HTTP
* [CORS](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS) <span class="span-mb"></span>
Cross-Origin Resource Sharing，跨來源資源共用。<br>
  > 瀏覽器在發送請求之前會先發送 preflight request (預檢請求)，確認伺服器端設定正確的 Access-Control-Allow-Methods、Access-Control-Allow-Headers 及 Access-Control-Allow-Origin 等 header，才會實際發送請求。<br><span class="span-mb"></span>
  > 使用 cookie 的情況下還需額外設定 Access-Control-Allow-Credentials header。<br><span class="span-mb"></span>
  > 針對不同源的請求而定的規範，透過 JavaScript 存取非同源資源時，server 必須明確告知瀏覽器允許何種請求，只有 server 允許的請求能夠被瀏覽器實際發送，否則會失敗。
  > :::tip 同源的條件
  > 1. 相同的通訊協定 (protocol)，即 `http` / `https`
  > 2. 相同的網域 (domain)
  > 3. 相同的通訊埠 (port)
  > :::
  > [⋯ Reference](https://shubo.io/what-is-cors/)

### 後端框架
* [Express.js](https://expressjs.com/)
  > Express 是 Node.js 環境下提供的一個輕量後端框架，自由度極高，透過豐富的 HTTP 工具，能幫助快速開發後端應用程式。
  > [⋯ Reference](https://hackmd.io/@Heidi-Liu/note-be201-express-node)


## 7 th

<style>
  .span-mb {
    display: block;
    margin-bottom: 0.5rem;
  }
</style>