<script setup>
import FoldCode from '../.vitepress/components/FoldCode.vue'

</script>

# Feb. 2023

## 1 st
### [Vitepress](https://vitepress.vuejs.org/guide/theme-search#search) [docsearch](https://docsearch.algolia.com/)
* 使用 algolia 新增搜尋功能
  > 1. 註冊 [algolia](https://www.algolia.com/)
  > 2. 在 algolia 創建 index 並獲取<br>`Application ID`、`Search-Only API Key`、`Admin API Key`
  > 3. 修改 `docs/.vitepress/config.ts`
  > ```ts
  > defineConfig({
  >   themeConfig: {
  >     ...
  >   },
  >   algolia: {
  >     appId: '', // 填入 Application ID
  >     apiKey: '', // 填入 Search-Only API Key
  >     indexName: '' // 填入剛剛創建的 index 名稱
  >   },
  > })
  > ```
  > 4. 修改 Github Secrets<br>
  > `Your Repo -> Settings -> Security / Secrets and variables / Actions`<br>
  > 新增兩個 repository secret
  > * `API_KEY`：填入 `Admin API Key`
  > * `APPLICATION_ID`：填入 `Application ID`
  > 5. 在專案的根目錄下創建 `crawlerConfig.json`<br>
  > 這是告訴 algolia 需要爬取的配置
  > ```json
  > {
  >   "index_name": "...", // 填入 index 名稱
  >   "start_urls": ["..."], // 填入專案網址
  >   "rateLimit": 8,
  >   "maxDepth": 10,
  >   "selectors": {
  >     "lvl0": {
  >       "selector": "",
  >       "defaultValue": "Documentation"
  >     },
  >     "lvl1": ".content h1",
  >     "lvl2": ".content h2",
  >     "lvl3": ".content h3",
  >     "lvl4": ".content h4",
  >     "lvl5": ".content h5",
  >     "content": ".content p, .content li"
  >   },
  >   "selectors_exclude": [
  >     "aside",
  >     ".page-footer",
  >     ".next-and-prev-link",
  >     ".table-of-contents"
  >   ],
  >   "js_render": true
  > }
  > ```
  > 6. 在 `.github/workflows` 目錄下，建立 `algolia.yml` 檔案（名稱可自行更改）
  > ```yaml
  > name: algolia
  > on:
  >   push:
  >     branches:
  >       - main # 若主分支為 master 記得更改
  > jobs:
  >   algolia:
  >     runs-on: ubuntu-latest
  >     steps:
  >       - uses: actions/checkout@v2
  >       - name: Get the content of algolia.json as config
  >         id: algolia_config
  >         run: echo "config=$(cat crawlerConfig.json | jq -r tostring)" >> $GITHUB_OUTPUT
  >       - name: Push indices to Algolia
  >         uses: signcl/docsearch-scraper-action@master
  >         env:
  >           APPLICATION_ID: ${{ secrets.APPLICATION_ID }}
  >           API_KEY: ${{ secrets.API_KEY }}
  >           CONFIG: ${{ steps.algolia_config.outputs.config }}
  > ```
  > :::info
  > 這裡是使用 Github Actions 在 Docker 中執行的 AlgoliaDocSearch scraper action，當我們推送到 `main` 分支時就會立即執行這個任務。
  > ::: 
  >
  > [⋯ Reference](https://blog.csdn.net/weixin_42429718/article/details/128361258)

## 2 nd
### VueUse
* [useWindowScroll](https://vueuse.org/core/usewindowscroll/)
  > 響應式的 window scroll。
  > ```ts
  > const { x, y } = useWindowScroll()
  > ```

### 問題
* `ref`、`computed`、`watch` 只能在 setup 使用
* `computed` 裡面不能有副作用
* `watch` 的對象只能是 `ref` 或 `function`（內部要取用到響應式資料）

### 學習資源
* [前端森林](https://fesites.netlify.app/)
  > 整理了前端知識網頁、期刊、工具等網站。
* [Learn Git Branching](https://learngitbranching.js.org/?locale=zh_TW)
  > 互動式的 git 視覺化和教學，可利用此應用程式來學習和挑戰掌握 git。

## 4 th
### 工具
* [Component Party](https://component-party.dev/)
  > 關於 Web 組件 JS 框架的語法和特性概述。

### 後端框架
* [Koa.js](https://koajs.com/)
  > 基本設置
  > 1. 安裝 Koa.js
  > ```
  > pnpm install koa -D
  > ```
  > :::tip -D
  > 將下載的套件歸類在 `package.json` 的 `devDependencies`。
  > :::
  > 2. 加入路由設定
  > ```
  > pnpm install koa-router -D
  > ```
  > 3. 加入 koa-body
  > ```
  > pnpm install koa-body -D
  > ```
  > 4. 新增 CORS
  > ```
  > pnpm install @koa/cors -D
  > ```

* 新增並設置 `server.js` 檔案

<FoldCode>

```javascript
const Koa = require('koa')
const Router = require('koa-router')
const { koaBody } = require('koa-body')
const cors = require('@koa/cors')

const app = new Koa() // 建立一個新的 Koa 實體 app
const router = new Router()

app.use(cors())
app.use(koaBody())

// Web 請求會經過這個 function
router
    .get('/url/:id', ctx => { ... })
    .delete('/url/:id', ctx => {
      ctx.params.id // 取得網址參數的 id
      ctx.request.body // 表單送過來的資料
        
      ctx.request.query // 查詢字串
      ctx.query // 查詢字串
        
      ctx.status = 200 // 回傳狀態
})

app.use(router.routes())
app.listen(3000) // 伺服器設在 3000 這個 port
```

</FoldCode>

### HTTP
* [Status Code 狀態碼](https://www.restapitutorial.com/httpstatuscodes.htmls)

| Code | Content | 意義 |
| -- | -- | -- |
| `200` | OK | 請求成功 |
| `201` | Created | 請求成功且有一個新的資源已經依據需要而被建立 |
| `204` | No Content | 請求成功，但客戶端不需要更新目前的頁面 |
| `400` | Bad Request | 被認為是客戶端錯誤，服務器不能或不會處理請求 |
| `401` | Unauthorized | 客戶端請求尚未完成，因為缺少所請求資源的有效身份驗證憑據 |
| `404` | Not Found | 服務器找不到請求的資源 |


<style>

  .vp-doc th {
    min-width: 4.7rem;
  }
</style>

## 6 th
### HTTP
* [CORS](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/CORS) <span class="span-mb"></span>
Cross-Origin Resource Sharing，跨來源資源共用。<br>
  > 瀏覽器在發送請求之前會先發送 preflight request (預檢請求)，確認伺服器端設定正確的 Access-Control-Allow-Methods、Access-Control-Allow-Headers 及 Access-Control-Allow-Origin 等 header，才會實際發送請求。<br><span class="span-mb"></span>
  > 使用 cookie 的情況下還需額外設定 Access-Control-Allow-Credentials header。<br><span class="span-mb"></span>
  > 針對不同源的請求而定的規範，透過 JavaScript 存取非同源資源時，server 必須明確告知瀏覽器允許何種請求，只有 server 允許的請求能夠被瀏覽器實際發送，否則會失敗。
  > :::tip 同源的條件
  > 1. 相同的通訊協定 (protocol)，即 `http` / `https`
  > 2. 相同的網域 (domain)
  > 3. 相同的通訊埠 (port)
  > :::
  > [⋯ Reference](https://shubo.io/what-is-cors/)

### 後端框架
* [Express.js](https://expressjs.com/)
  > Express 是 Node.js 環境下提供的一個輕量後端框架，自由度極高，透過豐富的 HTTP 工具，能幫助快速開發後端應用程式。
  > [⋯ Reference](https://hackmd.io/@Heidi-Liu/note-be201-express-node)


## 7 th
### 套件
* [FormKit](https://formkit.com/)
  > 免費開源的 Vue 表單構建框架，可簡化表單結構、生成、驗證、主題、提交、錯誤處理等。
### JS
* Compose
  > 從右到左參數執行。
  > ```js
  > (fa, fb, fc) => x => fa(fb(fc(x)))
  > ```
  > 可以填入多個參數。
  > ```js
  > const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x)
  > ```
* Pipe
  > 從左到右參數執行。
  > ```js
  > (fa, fb, fc) => x => fc(fb(fa(x)))
  > ```
  > 可以填入多個參數。
  > ```js
  > const pipe = (...fns) => (x) => fns.reduce((v, f) => f(v), x)
  > ```
[⋯ Reference](https://medium.com/hannah-lin/fp-compose-pipe-8df3f5364648)

## 8 th
### JS 事件循環
* 執行順序
  > 同步任務 —> 異步任務 微任務（microtask） —> 異步任務 宏任務（macrotask）
* 同步任務
  > 主執行緒上排隊執行的任務，只有前一個任務執行完畢，才能繼續執行下一個任務。<br>
  > 包括：`new promise()`、`console.log()`。
* 異步任務
  > 不進入主執行緒、而進入「任務佇列」的任務。<br>
  > 只有等主執行緒任務全部執行完畢，「任務佇列」的任務才會進入主執行緒執行。<br>
  > 分成微任務（microtask）和宏任務（macrotask）。
* 微任務（microtask）<br>
  > * 發起者
  >   > JS 引擎
  > * 具體事件：
  >   > 1. Promise
  >   > 2. MutaionObserver
  >   > 3. Object.observe（已廢棄，Proxy 物件替代）
  >   > 4. process.nextTick（Node.js）
* 宏任務（macrotask）
  > * 發起者
  >   > 宿主（Node、瀏覽器）
  > * 具體事件：
  >   > 1. script (可以理解為外層同步程式碼)
  >   > 2. setTimeout / setInterval
  >   > 3. UI rendering / UI 事件
  >   > 4. postMessage, MessageChannel
  >   > 5. setImmediate, I/O（Node.js）

[⋯ Reference](https://juejin.cn/post/7150103625270820901?share_token=79b7a64c-90fd-449e-bb92-23e464ad78e2)

### 瀏覽器
* 瀏覽器多執行緒
  > 1. JS 引擎執行緒：<br>用於解釋執行 JS 程式碼、使用者輸入、網路請求等。
  > 2. GUI 渲染執行緒：<br>繪製使用者介面，與 JS 主執行緒互斥（因為 JS 可以操作 DOM，進而會影響到 GUI 的渲染結果）。
  > 3. http 非同步網路請求執行緒：<br>處理使用者的 GET、POST 等請求，等回傳結果後將 callback function 推入到任務佇列。
  > 4. 定時觸發器執行緒：<br>setInterval、setTimeout 等待時間結束後，會把執行函數推入任務佇列中。
  > 5. 瀏覽器事件處理執行緒：<br>將 click、mouse 等 UI 互動事件發生後，將要執行的 callback function 放入到事件佇列中。

[⋯ Reference](https://juejin.cn/post/6969028296893792286#heading-0)

## 15 th
### 工具
* [ColorSpace](https://mycolor.space/)
  > 配色網站。

### 學習資源
* [前端題庫](https://www.explainthis.io/zh-hant/forum)
* [Front End Interview Handbook](https://www.frontendinterviewhandbook.com/javascript-questions)

### JS
* `process.nextTick()`
  > 是 Node 的一個定時器，讓任務可以在指定的時間運行。<br>
  > 其中 Node 一共提供了 4 個定時器，它們分別是 `setTimeout()`、`setInterval()`、`setImmediate()`、`process.nextTick()`。<br>
  > 它是在本輪循環執行的，而且是所有異步任務裏面最快執行的。<br>
  > Node 執行完所有同步任務，接下來就會執行 `process.nextTick` 的任務隊列。

  > 微任務隊列追加在 `process.nextTick` 隊列的後面，也屬於本輪循環。<br>
  > 所以，下面的程式碼總是先輸出 `nextTick`，再輸出 `.then`。<br>
  > 以下全部 `process.nextTick` 的回調函數，執行都會早於 Promise 的。
  > ```js
  > process.nextTick(() => console.log(1))
  > Promise.resolve().then(() => console.log(2))
  > process.nextTick(() => console.log(3))
  > Promise.resolve().then(() => console.log(4))
  >
  > // 1 3 2 4
  > ```

<style>
  .span-mb {
    display: block;
    margin-bottom: 0.5rem;
  }
</style>