# Nov. 2022

## 1 st
### 打包工具
  * Turbopack
  > Turbopack 是針對 JavaScript 和 TypeScript 優化的增量打包工具。<br>
  > 由 Webpack 的創建者和 Next.js 團隊使用 Rust 編寫。
### JavaScript 與 TypeScript 執行環境
  * Node.js
  > 基於 V8 引擎，並且是由 C++ 語言所建構
  * Deno
  > 基於 V8 引擎，並且是由 Rust 語言所建構<br>
  > 內建支援 TypeScript 執行<br>
  > 不再需要如 npm 的套件管理工具，同時扮演了套件管理系統的角色<br>
  > 如果要指定特定版本的套件也可以在 URL 中指定<br>

  其他詳細參考：https://ianchen0119.gitbook.io/deno/an-zhuang-bing-shi-yong-deno/deno-gen-node.js-de-zhu-yao-cha-yi
  
## 3 rd
### 工具
  * Yup
  > 第三方驗證函式庫<br>
  > 用於解析和驗證 JS 的生成器，使用 object 的驗證套件<br>
  > schema 可以說是對於「資料格式」與「數值」的一種描述架構，透過事先定義 schema 就像先訂好規則，然後要求 form 表單的資料要能夠匹配 schema，而 Yup 就是幫助我們整合這兩者的工具之一。<br>
  > * 優點
  > 1. 每個檢核子介面都設計淺顯易懂，且可以串接、好閱讀
  > 1. 基本檢核一應俱全且統一
  > * 缺點
  > 1.  yup 內的程式碼出錯時，不會有任何反應<br>
  >
  > 建議都需要用 `try-catch` 包起來比較保險。

## 4 th
### CSS
  * `::selection`
  > 此偽元素將樣式應用於文件中已被使用者選取強調的部分（例如在文件上單擊並拖動鼠標）。

### CSS 框架
  * [Tailwind Tips](https://www.protailwind.com/tips)
  > 集合了有關 Tailwind 的有用小訣竅等。

### 工具
  * [Dropcode](https://github.com/egoist/dropcode)
  > 簡單輕量的片段程式碼管理器

## 5 th
### Javascript
  
  * 淺拷貝 Shallow Copy
  > 原始物件資料與複製物件資料「並非完全獨立」，可能第一層就有指向相同地址的資料，也可能第二層才有指向相同地址的資料。彼此資料內容的改變可能會互相影響。
  * 深拷貝 Deep Copy
  > 原始物件資料與複製物件資料「完全獨立」，沒有任何一層資料指向相同的地址。彼此資料內容的改變不會互相影響。<br>
  > 1. `JSON.parse(JSON.stringify(obj))`<br>
  > > 某些值經過 `JSON.stringify/parse` 處理後，會產生變化：
  > > * `undefined`：會連同 key 一起消失
  > > * `NaN`：會被轉成 `null`
  > > * `Infinity`：會被轉成 `null`
  > > * `regExp`：會被轉成空 `{}`
  > > * `Date`：型別會由 Data 轉成 string<br>
  > 2. `_.cloneDeep(obj)`<br>
  > > ladash 內部的 API
  > 3. Recursive deepCopyFunction
  > > 寫一份遞迴函式，遍歷 Object data 每一層級資料，將其完全複製新的一份。

  ![](https://www.programfarmer.com/article/javaScript/javascript-shallow-copy-deep-copy/05.png)
  圖片來源：https://www.programfarmer.com/articles/javaScript/javascript-shallow-copy-deep-copy

## 6 th
### 技術
  * CSR (Client-Side Rendering)
  > 表示所有的頁面渲染 (render) 都透過瀏覽器端的 JS 來完成。<br>
  > 所有的邏輯、取資料、路由、template 都在客戶端處理。
  > * 優點
  > 1. 頁面的更新或是換頁都不需要刷新頁面，在使用體驗上相較於傳統的 SSR 應用會順暢許多。
  > * 缺點
  > 1. 載入速度通常較慢，尤其是在低階的行動裝置上。<br>
  > 原因如前所述，因為 CSR 要等待 JS 的下載及執行 render ，所以 CSR 頁面載入的前幾秒，頁面上會沒有東西或是只有一些骨架。<br>
  > 使用者必須要等待一段時間才能看到頁面的內容，相對來說會是較差的使用者體驗。
  > 1. SEO 較差，因為 CSR 的頁面對於爬蟲是比較不友善的。<br>
  > 雖然爬蟲有辦法執行 JS，但爬蟲也有一些 JavaScript render 頁面的限制。
  

  * SSR (Server-Side Rendering)
  > 表示伺服器收到使用者的請求之後，在伺服器端生成完整的 HTML，再回傳給使用者。<br>
  > 因為生成 HTML 的時候會在伺服器端先取得內部或外部 API 資料，所以相較於 CSR 從瀏覽器端取資料的模式，SSR 可以省去多次的來回往返。
  > * 優點
  > 1. 需要的 JS 比較少，因此有較快的 TTI，可以較快開始互動。<br>
  > 原因是相較於 CSR 所有 render 的邏輯都包含在 JS 中，SSR 已經在伺服器端把 render 的工作做完了，SSR 方案中瀏覽器端需要的 JS 理論上會比較少，所以會比較快達到 TTI。<br>
  > 1. 有更多的 JS 預算可以留給其他第三方 JS 使用。
  > 1. SEO 較佳。<br>
  > 因為 SSR 產生的完整 HTML 可以很容易的被爬蟲解讀，不需要想辦法執行 JS。
  > * 缺點
  > 1. 較慢的 TTFB。<br>
  > 因為在伺服器產生完整的 HTML 很花時間。如果同時有許多人造訪 server 造成負擔很重，或是有一些非常慢的 API，都有可能讓 server 的回應速度非常慢。
  > 1. 互動性體驗差。<br>
  > 因為 SSR 的頁面在每次互動之間都要重新讀取頁面，這在使用體驗上就不如 CSR 的頁面順暢，也是現代 web app 大多數會採用 CSR 方案的主要原因。
  
  參考資料：https://shubo.io/rendering-patterns/

  ::: tip
  * FCP (First Contentful Paint，使用者可以看到頁面上的重要內容的時間點) 
  * TTI (Time-to-Interactive，使用者首次可以跟頁面互動的時間點)<br>
  在 TTI 之前，使用者點畫面上任何東西都不會有反應。
  * TTFB (Time to First Byte，從瀏覽頁面的動作開始到瀏覽器收到第一個 byte 所需要的時間)
  :::



## 7 th
### CSS
  * 偽元素
  > 它不是真正網頁裡的元素，但行為與表現和真正網頁元素一樣，也可以對其使用 CSS 操控。<br>
  > 在 W3C 的定義裡總共有五個偽元素：<br>
  > `::before`、`::after`、`::first-line`、`::first-letter` 和 `::selection`。
  * `::before` 與 `::after`
  > 最常使用的偽元素，兩者都是以 `display: inline-block;` 的屬性存在。<br>
  > `::before` 是在原本的元素<span class="y-mark">之前</span>加入內容，`::after` 則是在原本的元素<span class="y-mark">之後</span>加入內容。<br>
  > 同時偽元素也會<span class="y-mark">繼承</span>原本元素的屬性。<br>
  
  > 一定要具備 content 的屬性，就算是只有 `content: "";` 都可以，因為沒有 content 的偽元素是不會出現在畫面上的，然而 content 是個很特別的屬性，它可以使用 attr 直接獲取內容元素的屬性值 (attribute）。<br>
  > content 內容是可以<span class="y-mark">相加</span>的，不過用法不像 JS 使用 + 號來相連，而是直接用一個空白鍵就可以不斷的累加下去。<br>
  
  > 偽元素的內容實際上不存在網頁裡 (如果打開瀏覽器的開發者工具，是看不到內容的)，所以如果在裡頭塞了太多的重要的內容，反而會影響到 SEO 的成效，因此對於使用偽元素的定位，還是當作<span class="y-mark">輔助</span>性質會比較恰當。

## 10 th
### CSS
  * `initial`：恢復為該 css 屬性的初始值。
  > 每個 css 屬性都有其初始值（initial value），例如背景色的初始值就是透明。
  * `inherit`：繼承最近的父層 css 屬性值。
  > 每個 css 屬性也都有繼承性（inherited）。<br>
  > 例如 `color` 有繼承性，而 `background-color` 則無。
  * `unset`：是 `inherit` 和 `initial` 的結合。
  > 在屬性有繼承性時，設定 `unset` 會等同於 `inherit` 的功能。<br>
  > 無繼承性時，設定 `unset` 則等同於 `initial`。
  * `revert`：優先恢復為瀏覽器預設。
  > 無瀏覽器預設則等同 `unset`。


### HTML
  * `<iframe>`：內嵌框架 (Inline Frame)
  > 所謂的內嵌框架（內聯框架），用來在一個 HTML 網頁裡面嵌入另外一個 HTML 網頁。<br>
  > 但一般如果不是用來嵌入外站的內容，還是盡量少用 `iframe`，因為 `iframe` 還是對網頁效能、維護性和 SEO 有非正面的影響。
  > * `src`：指定要被嵌入的網頁的網址 (URL)
  > * `height`：指定 iframe 的高度，單位為像素 (pixel)
  > * `width`：指定 iframe 的寬度，單位為像素 (pixel)
  > * `name`：指定 iframe 的名稱
  > * `sandbox`：當有這屬性時，表示針對 iframe 裡面的網頁啟用一些限制條件。<br>
  > 屬性值如果留空表示啟用所有限制，當有設定值的時候表示移除這些限制，你可以用空格設定移除多個限制條件。<br>
  >
  > 參考：https://www.fooish.com/html/iframe-tag.html

## 12 nd
* `clamp(MIN, VAL, MAX)`
  > 包含三個數值，定義「最大值、最小值以及中間的數值」。<br>
  > 其中 `MIN` 表示最小值，`VAL` 表示首選值，`MAX` 表示最大值。
  > 1. 如果 `VAL` 在 `MIN` 和 `MAX` 範圍之間，則使用 `VAL` 作為函數回傳值。
  > 1. 如果 `VAL > MAX`，則使用 `MAX` 作為回傳值。
  > 1. 如果 `VAL < MIN`，則使用 `MIN` 作為回傳值。<br>
  >
  > 範例：
  > ```javascript
  > clamp(200px, 100%, 300px);
  > ```

## 15 th
### 配置
* [Package.json](../notes/front-end/package-json.md)
> 個人筆記連結





  

<style>
  .y-mark {
    background-color: #fff6ba;
    padding: 0.15rem;
  }

</style>