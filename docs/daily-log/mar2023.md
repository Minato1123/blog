<script setup>
import FoldCode from '../.vitepress/components/FoldCode.vue'
</script>

# Mar. 2023
## 1 st
### 前端
* Fine-Grained Reactivity
  > * Signal<span class="span-mb"></span>
  > 反應系統中最主要的部分。
  > 由 getter、setter 和 value 所組成。<br>
  > 儘管在學術論文中經常被稱為 Signal，但它們也被稱為 Observables, Atoms, Subjects 或 Refs。
  > * Reactions<span class="span-mb"></span>
  > 被稱為 Effects, Autoruns, Watches 或 Computeds，它們觀察 Signal，每次其值更新時重新運行。<br>
  > 每當 Signal 被執行（發送 Signal），wrapping function 就會偵測到並自動訂閱它。
  >
  > 這就是所有我們需要實現 Fine-Grained Reactivity 的元件。<br>
  > Signal 和 Reaction（被觀察者和觀察者）。
  > 
  > * Derivations<span class="span-mb"></span>
  > 時常需要以不同的方式表示數據，並在多個 Reaction 中使用相同的 Signal。<br>
  > 可以在 Reaction 中編寫這些邏輯，甚至提取一個輔助函數。<br>
  > 但有時候計算衍生值的成本很高，重複做這些工作並不好。<br>
  > 因此，我們有第三個基本原始元件，類似於函數備忘錄，可以將中間計算的結果存成它們自己的 Signal。<br>
  > 這些被稱為 Derivations，但也被稱為 Memos, Computeds, Pure Computeds 等。
  > 
  > [⋯ Reference](https://dev.to/ryansolid/a-hands-on-introduction-to-fine-grained-reactivity-3ndf)


### 套件
* chokidar
  > 封裝 Node.js 監控文件系統文件變化功能的套件。

## 2 nd
### 問題
* 透過字串路徑取得物件資料
  > ```javascript
  > const data = {
  >   id: 1,
  >   detail: {
  >     img: "the-img",
  >     img2: "the-img2"
  >   }
  > }
  > 
  > const name = "detail.img"
  > ```
  > * 方法一：`new Function()`
  > ```javascript
  > new Function(`return data.${name}`)() // "the-img"
  > ```
  > `new Function()` 實際上是透過運行時藉由參數傳遞過來的字串所創建，因此它允許我們將任意字串變為函數。
  > * 方法二：Lodash 的 `get`
  > ```javascript
  > import _ from "lodash"
  > 
  > const img = _.get(data, name) // "the-img"
  > ```

## 6 th
### 工具
* [Babel](https://babeljs.io/)
  > 使用最新版本的 JavaScript 編寫程式碼的工具。<br>
  > 當環境本身不支援某些特性時，Babel 會幫助將這些特性編譯成可支援的版本。
* [gulp](https://gulpjs.com/)
  > Gulp 是一個開源 Task runner，建構於 nodejs 與 npm 上，基於 Stream 方式自動化整合套件的方式從 Source 進行每一個 Task，最後到達 Destination。<br>
  > 開發者可以使用它構建自動化工作流程，Gulp 可以編譯 Sass、編譯 JavaScript 語法至相容性較高的 ES5、圖片優化壓縮、打包程式碼等等的事情。
* [Broccoli](https://github.com/broccolijs/broccoli)
  > 用來快速構建項目的工具，可以用它對檔案進行混淆與壓縮，還可以透過其他的 Broccoli 相關套件完成許多功能。

## 7 th
### 套件
* [FZF](https://fzf.netlify.app/docs/latest)
  > 是使用 Go 構建的基於命令行的模糊查找器。<br>
  > 模糊查找器可以輸入要查找的字串中出現的幾個字符，並從字串列表（或物件）中快速獲取該字串（或物件）。
* [esno](https://github.com/esbuild-kit/esno)
  > 基於 esbuild 的 TS / ESNext node 執行時，會針對不同的模組化標準，採用不同的方案。
* [immer](https://github.com/immerjs/immer)
  > 小型套件，可以以更方便的方式使用不可變（immutable）的狀態。<br>
  > 透過對當前的狀態進行修改，創建下一個不可變的狀態。
* [XState](https://xstate.js.org/)
  > 狀態管理（State Management）的 Library，負責儲存及描述各種狀態與各種狀態間的轉換，整個核心都源自於 Statecharts。<br>
  > 需要定義好整個應用程式會有哪些狀態，和每個狀態下能轉換到哪些狀態（順序性）以及它們之間如何轉換。
  >
  > [⋯ Reference](https://blog.jerry-hong.com/posts/xstate-introduction)
:::tip 有限狀態機（Finite State Machine, FSM）
一種描述物件在各種狀態之間轉換的數學模型，通常為一個狀態轉換圖。<br>
描述系統在不同狀態下的行為，以及由一個狀態轉移到另一個狀態的條件和過程。
:::

## 9 th
### Vue
* [Computed Debugging](https://vuejs.org/guide/extras/reactivity-in-depth.html#computed-debugging)
  > 當 `reactive` 屬性或 `ref` 作為依賴被當前的 `computed` **第一次追蹤**時，將會觸發 `onTrack`。<br>
  > 當依賴的變更觸發了 watcher 時，將會觸發 `onTrigger`。<br>

<FoldCode>

```javascript
const count = ref(0)
const plusTenA = computed(() => count.value + 10, {
  onTrack(e) {
    console.log('onTrack')
  },
  onTrigger(e) {
    console.log('onTrigger')
  }
})

const plusTenB = computed(() => count.value + 10,
{
  onTrack(e) {
    console.log('onTrack')
  },
  onTrigger(e) {
    console.log('onTrigger')
  }
})

console.log(plusTenA.value) // 觸發 plusTenA 的 onTrack
console.log(plusTenB.value) // 觸發 plusTenB 的 onTrack
```

</FoldCode>

## 10 th
### JS
* 自動化腳本：更改檔名

<FoldCode>

```javascript
const fs = require('fs') // fs 模組來讀取目錄下的所有檔案
const path = require('path') // 提供了一組與檔案路徑有關的實用工具函式

// 指定路徑（絕對路徑）
const directoryPath = '/Users/carrie/Documents/Projects/theFolder'

fs.readdir(directoryPath, (err, files) => {
  if (err) {
    console.log('Error getting directory information:', err)
  } else {
    files.forEach(file => {
      const filePath = path.join(directoryPath, file) // 原檔案路徑
      const newFilePath = path.join(directoryPath, 'new' + file) // 新檔案路徑

      fs.rename(filePath, newFilePath, err => { // 更動檔案路徑
        if (err) {
          console.log(`Error renaming file ${file}:`, err)
        } else {
          console.log(`File ${file} renamed to ${newFilePath}`)
        }
      })
    })
  }
})
```

</FoldCode>

### 前端
* i18n（internationalization 國際化）
  > 透過設計和開發可適應多種語言和文化的軟體產品和服務的方法。<br>
  > i18n 通常涉及在網站或應用程式中使用**多語言字串、日期、貨幣格式**等，以及在使用者介面中提供**多語言支援**。<br>
  > 常見的前端 i18n 套件包括 `react-i18next`、[`vue-i18n`](https://vue-i18n.intlify.dev/)、`Angular i18n` 等。

## 12 nd
### JS
* `Object.assign(target, ...sources)`
  > 將所有可枚舉（enumerable）屬性的值從一個或多個 source object 分配到 target object，並回傳 target object。
  > 1. source object 屬性與 target object 屬性不同，則會被拷貝到 target object 中。
  > 2. 如果 target object 和 source object 有相同的屬性，target object 的屬性值會被 source object 的屬性值覆蓋掉。
  > 3. 如果有多個 source object 有相同的屬性，那麼 target object 的屬性將會被最後一個 source object 屬性覆蓋。
  > :::warning 注意
  > * 原本傳入的 target object 會被改動到！
  > * 繼承屬性和不可枚舉屬性不能拷貝。
  > :::
* 非破壞性 methods
  > ！不會改變原陣列，而是回傳原陣列操作後的拷貝！
  > 1. `toReversed()`<span class="span-mb"></span>
  > `.reverse()` 的非破壞性版本。
  > 2. `toSorted()`<span class="span-mb"></span>
  > `.sort()` 的非破壞性版本。
  > 3. `toSpliced()`<span class="span-mb"></span>
  > `.splice()` 的非破壞性版本，回傳原陣列變更後的版本，因此無法取得被刪除的元素。
  > 4. `with(index, value)`<span class="span-mb"></span>
  > 對應 `splice(index, 1, value)`，用來將指定位置的成員替換為新的值。
* `at()`
  > 可將一個整數作為參數，回傳對應位置的值，並且支援負的 index。
  > ```js
  > const arr = [5, 12, 8, 130, 44]
  > arr.at(2) // 8
  > arr.at(-2) // 130
  > ```
* `Array.of()`
  > 可將一組值轉換為陣列。
  > ```js
  > Array.of(1, 2, true, {}, [5, 6], 'a')
  > // [1, 2, true, {}, [5, 6], 'a']
  > ```

## 13 rd
### JS
* Generator Function
  > 1. `function*`<span class="span-mb"></span>
  > 函數內部使用 `yield` 語句，定義不同的內部狀態。
  > 2. 執行 Generator 函式的方法和一般函式一樣，只需要在函式後面加上 `()` 括號。<br>
  > 不同的是，呼叫 Generator 函數後，該函數並不執行，回傳的也不是函數運行結果，而是一個指向內部狀態的指針物件，這個指針物件實際上是一個 JavaScript 疊代器。
  > 3. 呼叫疊代器物件的 `next()`，使得指針移向下一個狀態。<br>
  > 每次呼叫 next 方法，內部指針就從函數頭部或上一次停下來的地方開始執行，直到遇到下一個 `yield` 語句（或 `return` 語句）為止。<br>
  > 換言之，Generator 函式是分段執行的，`yield` 語句是暫停執行的標記，而 `next()` 可以恢復執行。
  > :::tip `yield`
  > * 本身沒有回傳值，或者說總是回傳 `undefined`。
  > * `next()` 可以帶一個參數，該參數就會被當作上一個在 generator 中 `yield` 語句的回傳值。
  > （由於 next 方法的參數表示上一個 `yield` 語句的返回值，所以第一次使用 `next()` 時不能帶有參數）
  > * 如果用在一個表達式之中，必須放在括號裡面 e.g. `(yield 123)`。
  > :::
  > :::warning `for...of`
  > * 自動疊代 Generator 函數時生成的 Iterator 物件，且此時不再需要特別呼叫 `next()`。
  > * 一旦 `next()` 方法的回傳物件的 `done` 屬性為 `true` 時，`for...of` 就會中止，且不包含該回傳物件。
  > :::
  >
  > [⋯ Reference](https://pjchender.dev/javascript/js-generator/)
* `as const`
  > 將一個表達式的型別轉換為它的字面量型別（literal type）。<br>
  > 對於由字面值構成的物件和陣列，可以將型別轉換為唯讀的物件型別（readonly object type）或唯讀的陣列型別（readonly array type）。<br>
* `Symbol.iterator`
  > 可迭代物件（iterable object）具有 Symbol.iterator 的屬性，會回傳迭代器物件。
  > ```javascript
  > const arr = [1, 2, 3]
  > const iterator = arr[Symbol.iterator]() // Array Iterator {}
  > ```
  > 利用 `next()` 手動迭代。
  > ```javascript
  > iterator.next() // { value: 1, done: false }
  > iterator.next() // { value: 2, done: false }
  > iterator.next() // { value: 3, done: false }
  > iterator.next() // {value: undefined, done: true}
  > ```
  > `[...iterator]` 會取得 value 組成的陣列。
  > ```javascript
  > iterator.next() // { value: 1, done: false }
  > const a = [...iterator] // [2, 3]
  > ```

## 14 th
### 套件
* [vue-chemistry](https://github.com/vueuse/vue-chemistry)
  > 純粹響應式的 reactified JavaScript 函數庫。

### JS
* [Optional Chaining `?.`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Optional_chaining)
  > 可用來訪問物件的屬性或 callback function。<br>
  > 如果使用 `?.` 訪問的物件或呼叫的函數是 `undefined` 或 `null`，表達式會短路並且評估為 `undefined`，而不是拋出錯誤。

## 15 th
### JS
* Throttling（節流）
  > 限制一個函數在**一段時間內只能被調用一次**的行為。<br>
  > 例如，如果我們透過 500 毫秒進行限流，這表示在 500ms 的時間框架內不能被調用超過一次，此時任何額外函數調用都會被忽略。<br>
  > 參考套件：[lodash.throttle](https://lodash.com/docs/4.17.15#throttle)、[_.throttle](https://underscorejs.org/#throttle)。<span class="span-mb"></span>
  > throttle 函數的常見用例：
  > 1. 任何視窗調整大小後的一致 UI 更新
  > 2. Server 或客戶端上的性能密集型操作
* Debouncing（防抖）
  > **最後一次被調用**後經過 N 個時間單位後才會被調用。<br>
  > 它對看似已經解決的狀態作出反應，並表示事件和處理程序函數調用之間存在延遲。<br>
  > 參考套件：[lodash.debounce](https://lodash.com/docs/4.17.15#debounce)、[_.debounce](https://underscorejs.org/#debounce)<span class="span-mb"></span>
  > 需要最終對頻繁事件做出反應時，就可以使用 debounce。不需要中間狀態並且希望對事件的最終狀態做出反應時，Debounce 是很有用的。<br>
  > 儘管如此，在使用 debounce 時，仍需要考慮事件和對其作出反應之間的不可避免的延遲。<span class="span-mb"></span>
  > debounce 函數的常見用例：
  > 1. 異步搜索建議
  > 2. Server 上的更新批次處理

[⋯ Reference](https://redd.one/blog/debounce-vs-throttle)

## 17 th
* [Next.js](https://nextjs.org/)
  > 構建於 Node.js 之上的開源 Web 開發框架，支援基於 React 的 Web 應用程序功能，例如 Server 端渲染和生成靜態網站。
* [Nuxt.js](https://nuxt.com/)
  > 基於 Vue 的通用應用框架，預設了利用 Vue 開發 Server 端渲染的應用所需要的各種配置，主要關注的是應用的 UI 渲染。
* [Nest.js](https://nestjs.com/)
  > 用於構建高效、可擴展 Node.js 服務端應用程序的框架。<br>
  > 使用 TypeScript 構建的並且完全支援 TypeScript（仍可以使用純 JavaScript 編寫），並結合了 OOP、FP、FRP 的元素。

[⋯ Reference](https://blog.fundebug.com/2019/05/23/next-nuxt-nest/)

<style>
  .span-mb {
    display: block;
    margin-bottom: 0.5rem;
  }
</style>