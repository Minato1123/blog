import{_ as e,o as a,c as s,V as l}from"./chunks/framework.62adf23d.js";const m=JSON.parse('{"title":"May. 2023","description":"","frontmatter":{},"headers":[],"relativePath":"daily-log/may2023.md"}'),n={name:"daily-log/may2023.md"},o=l(`<h1 id="may-2023" tabindex="-1">May. 2023 <a class="header-anchor" href="#may-2023" aria-label="Permalink to &quot;May. 2023&quot;">​</a></h1><h2 id="_1-st" tabindex="-1">1 st <a class="header-anchor" href="#_1-st" aria-label="Permalink to &quot;1 st&quot;">​</a></h2><h3 id="web-api" tabindex="-1">Web API <a class="header-anchor" href="#web-api" aria-label="Permalink to &quot;Web API&quot;">​</a></h3><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver" target="_blank" rel="noreferrer">MutationObserver</a><blockquote><p>追蹤 DOM 的變化，無論是子節點的變動或內容、屬性的變動，並且獲得相關的資訊，以便作出後續的行動。</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> observer </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">MutationObserver</span><span style="color:#A6ACCD;">(callback)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><b>指定「被觀察的對象」</b></p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">observe</span><span style="color:#A6ACCD;">(target</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> options)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><ul><li><code>target</code>：受到觀察的 DOM 節點。</li><li><code>options</code>：初始化設定物件，用來指定 DOM 節點的哪些項目需要被觀察等相關設定。 <br><br><a href="https://ithelp.ithome.com.tw/articles/10277536" target="_blank" rel="noreferrer">⋯ Reference</a></li></ul></blockquote></li></ul><h2 id="_2-nd" tabindex="-1">2 nd <a class="header-anchor" href="#_2-nd" aria-label="Permalink to &quot;2 nd&quot;">​</a></h2><h3 id="元件庫" tabindex="-1">元件庫 <a class="header-anchor" href="#元件庫" aria-label="Permalink to &quot;元件庫&quot;">​</a></h3><ul><li><a href="https://headlessui.com/" target="_blank" rel="noreferrer">HeadlessUI</a><blockquote><p>完全未樣式化、完全可存取的 UI 元件，旨在與 Tailwind CSS 完美整合。</p></blockquote></li><li><a href="https://zagjs.com/" target="_blank" rel="noreferrer">Zag</a><blockquote><p>由有限狀態機所支援、不依賴於特定框架的 UI 元件。</p></blockquote></li><li><a href="https://www.inkline.io/" target="_blank" rel="noreferrer">inkline</a><blockquote><p>UI 元件庫，為構建高品質、可存取和可自定義的 Vue3 設計系統提供了開發者友好的基礎。<br> 旨在使用一致和表達性的 API 提供優秀的使用者界面（UI）、使用者體驗（UX）和開發者體驗（DX）。</p></blockquote></li></ul><h3 id="工具" tabindex="-1">工具 <a class="header-anchor" href="#工具" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li><a href="https://dreamsands.io/?ref=producthunt" target="_blank" rel="noreferrer">Dreamsands</a><blockquote><p>圖片轉程式碼平台，可以從任何圖片或截圖中生成程式碼，並在自己的專案中做使用。</p></blockquote></li></ul><h2 id="_3-rd" tabindex="-1">3 rd <a class="header-anchor" href="#_3-rd" aria-label="Permalink to &quot;3 rd&quot;">​</a></h2><h3 id="css" tabindex="-1">CSS <a class="header-anchor" href="#css" aria-label="Permalink to &quot;CSS&quot;">​</a></h3><ul><li><p><code>@layer</code><br></p><blockquote><p>依照 layer 宣告的順序來<span class="span-heightlight">決定樣式的優先順序</span>，後宣告的即使權重較小也會覆寫。</p></blockquote><blockquote><p><b>使用方式</b></p><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">@layer</span><span style="color:#A6ACCD;"> layer_name </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">/* ... */</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">@import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">example.css</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> layer</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">example</span><span style="color:#89DDFF;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><div class="warning custom-block"><p class="custom-block-title"><code>@layer</code> 也可以是巢狀結構。</p><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">@layer</span><span style="color:#A6ACCD;"> layer_container </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">@layer</span><span style="color:#A6ACCD;"> layer_A </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;font-style:italic;">@layer</span><span style="color:#A6ACCD;"> layer_B </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">/* ... */</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></div><div class="danger custom-block"><p class="custom-block-title">注意</p><ol><li>在<b>沒有</b> <code>!important</code> 的情況下，non-layered style 比 layered style 優先。<br>（就算寫在 layered style 之前也一樣）</li><li>在<b>皆有</b> <code>!important</code> 的情況下，layered style 比 non-layered style 優先。</li><li>即使沒有宣告所有 Layer 的順序，沒被宣告的 Layer 依然存在，且順序如同 style 中的順序往後<b>排在宣告過的 layer 後面</b>。</li></ol></div><p><a href="https://blog.boggy.tw/2022/05/04/css-layer/" target="_blank" rel="noreferrer">⋯ Reference</a></p></blockquote></li><li><p><code>@container</code></p><blockquote><p>可以<span class="span-heightlight">根據父容器的大小來設定元素的樣式</span>。<br> 要使用 container query，需要在父容器上聲明一個 containment context，以便瀏覽器知道苦可能會查詢此容器的尺寸。<br><br> 為此，可以使用 <code>container-type</code> 屬性：</p><ol><li><code>size</code>：創建一個查詢容器，支援對 inline 和 block 的尺寸進行查詢。</li><li><code>inline-size</code>：創建一個查詢容器，支援對 inline 的尺寸進行查詢。</li><li><code>normal</code>：創建一個查詢容器，但只提供樣式查詢，不支援任何尺寸的查詢。 <br><br></li></ol><p>另外，也可以使用 <code>container-name</code> 屬性為 containment context 命名。<br> 該名稱可以在 <code>@container</code> 查詢中使用，以便針對特定容器進行定位。</p></blockquote><blockquote><p><b>縮寫版本</b></p><div class="language-css line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">class-name</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  container</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> container-name / container-type</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><a href="https://juejin.cn/post/7044181023696879652" target="_blank" rel="noreferrer">⋯ Reference</a></p></blockquote></li></ul><h2 id="_4-th" tabindex="-1">4 th <a class="header-anchor" href="#_4-th" aria-label="Permalink to &quot;4 th&quot;">​</a></h2><h3 id="套件" tabindex="-1">套件 <a class="header-anchor" href="#套件" aria-label="Permalink to &quot;套件&quot;">​</a></h3><ul><li><p><a href="https://github.com/ardatan/feTS" target="_blank" rel="noreferrer">feTS</a></p><blockquote><p>使用 TypeScript 和 OpenAPI，以 end-to-end 的型別安全方式構建和使用 REST API 的新方法。<br></p></blockquote><blockquote><p><b>feTS Client</b><br> 具有完全型別安全性的 HTTP 客戶端，使用 OpenAPI 規範。<br> 可以自動從檔案中推斷型別，並提供一組具有型別安全性的 API，以與自己的 API 進行互動。</p></blockquote><blockquote><p><b>feTS Server</b><br> 創建具有完全型別安全性的 REST API 函式庫。<br> 若使用者是 JavaScript 環境，強烈建議使用 feTS Client 做配合。</p></blockquote></li></ul><h3 id="工具-1" tabindex="-1">工具 <a class="header-anchor" href="#工具-1" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li><a href="https://swagger.io/tools/swagger-ui/" target="_blank" rel="noreferrer">Swagger UI</a><blockquote><p>在沒有實現任何邏輯的情況下，對 API 的資源進行可視化和互動。<br> 根據 OpenAPI 規範自動生成，視覺化檔案使後端實現和客戶端使用都變得更輕鬆。</p></blockquote></li><li><a href="https://gradient.style/" target="_blank" rel="noreferrer">HD Gradients</a><blockquote><p>使用工具調整以產生漸變的 CSS 程式碼。</p></blockquote></li></ul><h2 id="_7-th" tabindex="-1">7 th <a class="header-anchor" href="#_7-th" aria-label="Permalink to &quot;7 th&quot;">​</a></h2><h3 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h3><ul><li><p><a href="https://github.com/vuejs/rfcs" target="_blank" rel="noreferrer">Vue RFCs</a></p><blockquote><p>Request For Comments<br> RFCs 流程的目的是提供一致且受控的途徑，讓新功能進入框架。<br> 許多更動（包括錯誤修復和文件改進）皆可以透過正常的 GitHub pull request workflow 來實作和審查。<br> 然而，有些改變是重大的，這些改變需要經過設計過程，並在 Vue 核心團隊和社群中產生共識。</p></blockquote><blockquote><p><b>RFC 過程</b></p><ol><li>Pending：當 RFC 作為討論主題提交時。<br>我們使用 Discussions 而不是 Pull Requests，因為前者提供更好的討論程序。</li><li>Active：當 RFC 被確認並正在實作時，該功能可能會以實驗性的方式發佈。</li><li>Landed：當 RFC 的建議更改在發佈中作為穩定版本時。</li><li>Rejected：當 RFC 被正式拒絕或取消時。</li></ol></blockquote></li></ul><h3 id="vscode-extension" tabindex="-1">VSCode Extension <a class="header-anchor" href="#vscode-extension" aria-label="Permalink to &quot;VSCode Extension&quot;">​</a></h3><ul><li><a href="https://github.com/pushqrdx/vscode-inline-html" target="_blank" rel="noreferrer">vscode-inline-html</a><blockquote><p>ES6 Template Strings 中對 HTML / CSS 的 Syntax Highlight、Emmet、IntelliSense 支援。<br> 在 JavaScript 或 TypeScript 檔案中使用 <code>/*html*/</code>、<code>html</code>、<code>/*css*/</code>、<code>css</code>、<code>/*style*/</code>、<code>style</code> 以及反引號 <code>\`</code>，可以在 Template 中獲得完整的編輯器支援。</p></blockquote></li></ul><h3 id="工具-2" tabindex="-1">工具 <a class="header-anchor" href="#工具-2" aria-label="Permalink to &quot;工具&quot;">​</a></h3><ul><li><a href="https://github.com/emmetio/emmet" target="_blank" rel="noreferrer">Emmet</a><blockquote><p>用於提升 HTML 和 CSS 語言編寫效率的 Web 開發工具包。<br> 可以輸入類似於 CSS 選擇器的表示式（縮寫），然後將其轉換為 HTML 片段。</p></blockquote></li></ul><h2 id="_8-th" tabindex="-1">8 th <a class="header-anchor" href="#_8-th" aria-label="Permalink to &quot;8 th&quot;">​</a></h2><h3 id="vue-1" tabindex="-1">Vue <a class="header-anchor" href="#vue-1" aria-label="Permalink to &quot;Vue&quot;">​</a></h3><ul><li><a href="https://vuejs.org/guide/scaling-up/sfc.html" target="_blank" rel="noreferrer">SFC</a><blockquote><p>Vue Single-File Components<br> 也被稱為 <code>*.vue</code> 檔案，是一種特殊的檔案格式。<br> 可以將 Vue 組件的 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 封裝在一個單獨的檔案中。</p></blockquote></li></ul><h3 id="套件-1" tabindex="-1">套件 <a class="header-anchor" href="#套件-1" aria-label="Permalink to &quot;套件&quot;">​</a></h3><ul><li><a href="https://github.com/HunYan-io/vite-plugin-vue-nested-sfc" target="_blank" rel="noreferrer">vite-plugin-vue-nested-sfc</a><blockquote><p>可以在 SFC 中嵌套 SFC。</p></blockquote></li><li><a href="https://github.com/cevr/ftld" target="_blank" rel="noreferrer">ftld</a><blockquote><p>針對 TypeScript 的小型函式庫，專注於提供一組 functional primitives 以協助建構堅固且具彈性的應用程式。<br> 使用 ftld 提供的函式和工具可以更有效且易維護的方式實現 functional programming 的概念和技術。</p></blockquote></li></ul><div class="tip custom-block"><p class="custom-block-title">tree-shakeable</p><p>與 JavaScript 優化和打包相關的術語。<br> 指的是能在打包過程中移除未使用的程式碼（dead-code），以減少最終應用程式的檔案大小。</p></div>`,30),t=[o];function r(c,p,i,b,d,u){return a(),s("div",null,t)}const y=e(n,[["render",r]]);export{m as __pageData,y as default};
