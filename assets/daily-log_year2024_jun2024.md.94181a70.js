import{_ as e,o as t,c as a,V as o}from"./chunks/framework.fa42150b.js";const b=JSON.parse('{"title":"Jun. 2024","description":"","frontmatter":{"outline":2},"headers":[],"relativePath":"daily-log/year2024/jun2024.md"}'),i={name:"daily-log/year2024/jun2024.md"},l=o('<h1 id="jun-2024" tabindex="-1">Jun. 2024 <a class="header-anchor" href="#jun-2024" aria-label="Permalink to &quot;Jun. 2024&quot;">​</a></h1><h2 id="_5-th" tabindex="-1">5 th <a class="header-anchor" href="#_5-th" aria-label="Permalink to &quot;5 th&quot;">​</a></h2><h3 id="solid-物件導向設計基本原則" tabindex="-1">SOLID 物件導向設計基本原則 <a class="header-anchor" href="#solid-物件導向設計基本原則" aria-label="Permalink to &quot;SOLID 物件導向設計基本原則&quot;">​</a></h3><ul><li>Single Responsibility principle（單一職責原則） <blockquote><p>一個 Class 應該只有一個職責，也就是說，每次針對軟體特定範圍的變更只應影響到特定範圍的 Class。</p></blockquote></li><li>Open / closed principle（開放／封閉原則） <blockquote><p>軟體實體（Class、Modules、Functions 等等）對於擴展是開放的，但對於修改是封閉的。 簡單來說即是希望可以加上新功能，但不會影響到現有功能。</p></blockquote></li><li>Liskov substitution principle（里斯克夫替換原則） <blockquote><p>物件應該可以在不影響現有程式正確性的情況下被他的子類別 實作替換。 原本父類別的所做的事情，換上繼承該父類別的子類時能不影響原先的運作。</p></blockquote></li><li>Interface segregation principle（介面分離原則） <blockquote><p>大量特定功能的 interface 比單一通用的 interface 來得更好。 如果一個 interface 過於萬能，依賴者數量過多，任何的更動都有可能對依賴它的依賴者造成影響。</p></blockquote></li><li>Dependency inversion principle（依賴反轉原則） <blockquote><p>高階模組不應依賴於低階模組，兩者皆應依賴於抽象實體。 抽象實體不應依賴於實作，實作應當依賴於抽象實體。 <span class="important">注意</span>項目越抽象的模組越高階，項目越具體的模組則越低階。 解決越特定問題的模組是低階模組，解決越通用問題的模組是高階模組。</p></blockquote></li></ul><p><a href="https://medium.com/jastzeonic/soild-%E4%BA%94%E5%8E%9F%E5%89%87%E9%82%A3%E4%B8%80%E5%85%A9%E4%BB%B6%E4%BA%8B%E6%83%85-4410b72e37f3" target="_blank" rel="noreferrer">⋯ Reference</a></p>',5),n=[l];function r(s,c,p,u,d,_){return t(),a("div",null,n)}const f=e(i,[["render",r]]);export{b as __pageData,f as default};
